action code
{:
		
:}

parser code
{:
	public void syntax_error(Symbol current_token) {
		report_error( "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null);
	}
:}

scan with
{:

:}

terminal MAIN, NULL, NINT_LIT, NRAT_LIT, NFLOAT_LIT, CHAR_LIT, PINT_LIT, PRAT_LIT, PFLOAT_LIT, BOOL, CHAR, INT, RAT, FLOAT, TOP, SEQ, TRUE, FALSE, TDEF, FDEF, ALIAS, START_IF, END_IF, ELSE, THEN, READ, PRINT, RETURN, LEN, LEQ, LT, GEQ, GT, IMPLICATION, EQ, NEQ, LCRBRA, RCRBRA, LSQBRA, RSQBRA, EQUAL, TYPESPEC, SEMICOLON, PLUS, MINUS, MULT, DIV, POWER, MOD, NOT, AND, OR, DOUBLECOLON, IN, IDENT, COMMA, LPAR, RPAR, DOT, LOOP_START, LOOP_END, BREAK, ASSIGN, QM, TRUE, FALSE;

nonterminal start_state, function, functions, statement, statements, expression, expressions, main, function_call, type, operator, decleration, key_vals, type_creation, args, index, numeric, nested_id, alias, null_expression, bool_lit;

precedence left OR, AND, NOT, IMPLICATION;
precedence left EQ, NEQ, LT, LEQ, GT, GEQ;
precedence left DOUBLECOLON;
precedence left PLUS, MINUS;
precedence left DIV, MULT, MOD;
precedence left POWER;
precedence left LPAR, RPAR;

precedence right ASSIGN;

start_state ::= functions main functions;

functions ::= functions func | functions decleration | functions type_creation | functions alias | ;

main ::= MAIN LCRBRA statements RCRBRA SEMICOLON;

func ::= FDEF IDENT LPAR args RPAR LCRBRA statements RCBRA TYPEDEF type SEMICOLON | FDEF IDENT LPAR RPAR LCRBRA statements RCBRA TYPEDEF type SEMICOLON | FDEF IDENT LPAR RPAR LCRBRA RCBRA TYPEDEF type SEMICOLON | FDEF IDENT LPAR args RPAR LCRBRA RCBRA TYPEDEF type SEMICOLON

decleration ::= IDENT TYPEDEF type SEMICOLON | IDENT TYPEDEF type ASSIGN expressions SEMICOLON;

type_creation ::= TDEF IDENT LCRBRA args RCRBRA SEMICOLON | TDEF IDENTIFIER LCRBRA RCRBRA SEMICOLON;

alias ::= ALIAS type IDENT SEMICOLON;

statements ::= statements statement | statement;

args ::= IDENT TYPEDEF type | args COMMA IDENT TYPEDEF type;

type ::= INT | FLOAT | RAT | BOOL | CHAR | DICT LT type COMMA type GT | DICT LT TOP COMMA type GT | DICT LT type COMMA TOP GT | SEQ LT type GT | SEQ LT TOP GT | IDENT;

expressions ::= expression | expressions COMMA expression;

statement ::= null_expression SEMICOLON | decleration | nested_id ASSIGN expression SEMICOLON | PRINT expression SEMICOLON | READ nested_id SEMICOLON | START_IF LPAR expression RPAR THEN statements END_IF | START_IF LPAR expression RPAR THEN statements ELSE statements END_IF | LOOP_START statements BREAK SEMICOLON statements LOOP_END | LOOP_START statements BREAK PINT_LIT SEMICOLON statements LOOP_END | LOOP_START statements LOOP_END | RETURN expression SEMICOLON | ALIAS type type SEMICOLON | type_creation;

expression ::= nested_id | numeric | CHAR_LIT | bool_lit | IDENT DOT LEN | expression operator expression | NOT expression | LPAR expression RPAR | function_call | LSQBRA expression RSQBRA | LSQBRA RSQBRA | nested_id index | IDENT IN nested_id | LCRBRA key_vals RCRBRA | LCRBRA RCRBRA;

bool_lit ::= TRUE | FALSE;

operator ::= PLUS | MINUS | DIV | MOD | POWER | EQ | LEQ | GEQ | LT | GT | AND | OR | DOUBLECOLON | IMPLICATION;

numeric ::= PINT_LIT | NINT_LIT | PFLOAT_LIT | NFLOAT_LIT | PRAT_LIT | NRAT_LIT;

function_call ::= IDENT LPAR expressions RPAR SEMICOLON | IDENT LPAR RPAR SEMICOLON;

nested_id ::= IDENT | nested_id DOT IDENT;

null_expression ::= expression | ;

index ::= LSQBRA expression RSQBRA | LSQBRA null_expression TYPEDEF null_expression RSQBRA | index LSQBRA expression RSQBRA | index LSQBRA null_expression TYPEDEF null_expression RSQBRA; 

key_vals ::= expression TYPEDEF expression | key_vals COMMA expression TYPEDEF expression;